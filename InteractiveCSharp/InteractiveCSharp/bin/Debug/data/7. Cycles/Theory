Циклы также являются управляющими конструкциями, позволяя в зависимости от определенных условий выполнять некоторое действие множество раз. В C# имеются следующие виды циклов:

 
Циклы

Операторы

for

 
foreach

 break

do	
continue

while

 

 

Цикл for

 

Цикл for имеет следующее формальное определение:

for ([инициализация счетчика]; [условие]; [изменение счетчика])

{

    // действия

 

}

 
Рассмотрим стандартный цикл for:

      for (int i = 1; i < 10; i++)

            {

                Console.WriteLine(" {0}^2 = {1}", i, i * i);

            }

            Console.ReadKey();

 

int i = 1 - создает и инициализирует счетчик i. Счетчик необязательно должен представлять тип int. Это может быть и другой числовой тип. И перед выполнением цикла его значение будет равно 0.

i < 10- условие, при котором будет выполняться цикл.

i++ - измение счетчика на единицу. (Можно уменьшать:i--).

 



В итоге, блок цикла сработает 9 раз, пока значение i не станет равным 10. И каждый раз это значение будет увеличиваться на 1.

 

Нам необязательно указывать все условия при объявлении цикла.

            int i = 0;

            for (; i < 9; )

            {

                Console.WriteLine("{0}^2 = {1}", ++i, i * i);

            }

 

 

Этот пример по сути эквивалентен первому примеру: у нас также есть счетчик, только создан он вне цикла. У нас есть условие выполнения цикла. И есть приращение счетчика уже в самом блоке for.

Так же мы можем написать следующий пример:

            int i = 0;

            for (; ; )

            {

                Console.WriteLine("{0}^2 = {1}", ++i, i * i);

                System.Threading.Thread.Sleep(500);

            }


 Формально определение цикла осталось тем же, только теперь блоки в определении у нас пустые: for (; ;). У нас нет условия, поэтому цикл будет работать вечно - бесконечный цикл.

 

Цикл foreach

Цикл foreach предназначен для перебора элементов в контейнерах. Формальное объявление цикла foreach:

foreach (типДанных  названиеПеременной in контейнер)

{

    // действия

}

 

пример:

            int[] array = new int[] { 1, 2, 3, 4, 5 };

            foreach (int i in array)

            {

             Console.WriteLine(i);

            }



Здесь в качестве контейнера выступает массив данных типа int. Поэтому мы объявляем переменную с типом int

 

Подобные действия мы можем сделать и с помощью цикл for:

                int[] array = new int[] { 1, 2, 3, 4, 5 };

                for (int i = 0; i < array.Length; i++)

                {

                    Console.WriteLine(array[i]);

                }

 

В то же время цикл for более гибкий. Если foreach последовательно извлекает элементы контейнера и только для чтения, то в цикле for мы можем перескакивать на несколько элементов вперед в зависимости от приращения счетчика, а также можем изменять элементы:

 

                     int[] array = new int[] { 1, 2, 3, 4, 5 };

                    for (int i = 0; i < array.Length; i++)

                        {

                            array[i] = array[i] * 2;

                            Console.WriteLine(array[i]);

                        }

 

Цикл do

В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while. И пока это условие истинно, цикл повторяется.

пример:

                    int i = 6;

                    do

                    {

                        Console.WriteLine(i);

                        i--;

                    }

                    while (i > 0);




Здесь код цикла сработает 6 раз, пока i не станет равным нулю. Но важно отметить, что цикл do гарантирует хотя бы одно выполнение действий, даже если условие в инструкции while не будет истинно.

 

Цикл while

В отличие от цикла do цикл while сразу проверяет истинность условий, и если оно истинно, то код цикла выполняется:

                    int i = 6;

                    while (i > 0)

                    {

                        Console.WriteLine(i);

                        i--;

                    }



 

Оператор break

Иногда возникает ситуация, когда требуется выйти из цикла, не дожидаясь его завершения. В этом случае мы можем воспользоваться оператором break.

Например:

                         int[] array = new int[] { 1, 2, 3, 4, 12, 9 };

                    for (int i = 0; i < array.Length; i++)

                    {

                     if (array[i] > 10)

                          break;

                        Console.WriteLine(array[i]);

                    }




Поскольку в цикле идет проверка, больше ли элемент массива 10. То мы никогда не увидим на консоли последние два элемента, так как, увидев, что элемент массива больше 10, сработает оператор break, и цикл завершится.

 

Оператор continue

Теперь поставим себе другую задачу. А что если мы хотим, чтобы при проверке цикл не завершался, а просто переходил к следующему элементу. Для этого мы можем воспользоваться оператором continue:

 

                    int[] array = new int[] { -8,-1,0, 4, 12, 9 };

                    for (int i = 0; i < array.Length; i++)

                    {

                        if (array[i] == 0)

                            continue;

                        Console.WriteLine(array[i]);

                    }



В этом случае цикл, когда дойдет до числа 0, которое не удовлетворяет условию проверки, просто пропустит это число и перейдет к следующему элементу массива.

Контрольные вопросы:
1) Что будет выведено в результате выполнения следующего кода:


                    int[] array = new int[] { -8,-1,0, 4, 12, 9 };

                    for (int i = 0; i < array.Length; i++)

                    {

                        if (array[i] == 0)

                            break;

                        Console.WriteLine(array[i]);

                    }
1 - -8 -1 0 4 12 9
2 - -8 -1
3 - -8 -1 0
